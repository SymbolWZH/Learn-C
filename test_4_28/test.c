#include <stdio.h>
/*
int 
short
char 在limits.h   0~255

float
double 在float.h 

#define MB_LEN_MAX    5 源码limits.h
#define SHRT_MIN    (-32768)
#define SHRT_MAX      32767
#define USHRT_MAX     0xffff
#define INT_MIN     (-2147483647 - 1)
#define INT_MAX       2147483647
#define UINT_MAX      0xffffffff
#define LONG_MIN    (-2147483647L - 1)
#define LONG_MAX      2147483647L
#define ULONG_MAX     0xffffffffUL
#define LLONG_MAX     9223372036854775807i64
#define LLONG_MIN   (-9223372036854775807i64 - 1)
#define ULLONG_MAX    0xffffffffffffffffui64


*/




//数据的存储
/*char
00000000  ->0
00000001  ->1
00000010  ->2
01111111  ->127
10000000  -> -128
10000001  -> 10000000  11111111 -127
....
11111110  -> 11111101  10000010 -2
11111111  -> 11111110  10000001 -1
*/

/*
int main()
{
    int i = -20; // 10000000000000000000000000010100 原码
                 // 11111111111111111111111111101011 反码
                 // 11111111111111111111111111101100  +1 补码
    unsigned int j = 10;
                 // 00000000000000000000000000001010  原码 反码 补码
                 // 
    printf("%d\n",i +j);
                //11111111111111111111111111101100 +
                //00000000000000000000000000001010 =
                //11111111111111111111111111110110 补码
                //又因为%d是有符号整型存在最高位所以计算出来的二进制减一取反
                //11111111111111111111111111110101
                //10000000000000000000000000001010 ->-10
    return 0;
}
*/

/*
int main()
{
    unsigned int i;//unsigned int i 如果这样声明表示这个数恒大于等于0
    for ( i = 9; i >=0; i--)// 所以i >=0一直成立
    {

        printf("%u\n",i );
        // 9  00000000000000000000000000001001
        // 死循环
      
    }
    
}
*/

/*
#include <string.h>
int main()
{
    char a[1000]; //char类型的范围是-128~127
    //因为整数在机器中是以补码的形式存储，可知“-0”和“-128”在char中存储是一样的。所以10000000其实就是-128总之char类型的范围是-128~127
    //无符号unsigned char 因为最高位不是符号位，和其他位的意义一样，所以最大是2的8次方-1也就是255，范围是0~255
    int i;
    for ( i = 0; i < 1000; i++)
    {
        a[i] = -1 - i;// -1 -2 -3 -4 .... -127 -128  127 126 125 ... 3 2 1 0 -1 -2 -127 -128... 127......
    }
    printf("%d",strlen(a));//找 \0 -> 0 所以是128 + 127
    //超出范围的数据如果是正数，则减去256；超出范围的数据是负数则加上256
    return 0;
}
*/

/*
unsigned char i = 0; // 无符号unsigned char 因为最高位不是符号位 最大是2的8次方-1也就是范围是0~255
int main()
{
    for ( i = 0; i <= 255; i++)// 所以i 恒小于等于255 所以会死循环
    {
        printf("hello world \n");
    }
    return 0;
}
*/


///浮点型在内存中的存储和整型是不一样的 
/*解引用操作
一个*float类型可以访问  4 个字节
一个*double类型可以访问 3 个字节
一个*char类型可以访问   1 个字节
*/
//方式有点复杂
int main()
{
    int n =9;                             // 00000000 00000000 00000000 00001001
    float*pFloat = (float*)&n; 
    printf("n的值为： %d\n",n);//n的值为： 9
// IEEE 754规定：对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M
// 0 00000000 00000000000000000001001
// s   E                 M
// pFloat的值为： 0.00000000000000000001001 X 2^126 因为浮点数的指数E等于1-127
// 又因为Float的小数位只有6位 所以值为 0.000000
    printf("*pFloat的值为： %f\n",*pFloat);//*pFloat的值为： 0.000000

    *pFloat = 9.0;
// 9.0的在IEEE 754表现形式为 1001.0
// 前面留一位右移三位 得到 1.001 * 2^3  
// 前面1为正数 SEM S正为0负为1  所以 第一位为 0 
// E=2^3 = 3 而E要加上127因为是转得到130 二进制为10000010
// 然后是001 因为1.001后面是001 然后后面一直补0到32位
//得到 0 10000010 00100000000000000000000 
//因为是整数 补码等于原码 0 10000010 00100000000000000000000 转为10进制就得到1091567616
    printf("n的值为： %d\n",n);//n的值为： 1091567616
    printf("*pFloat的值为： %f\n",*pFloat);//*pFloat的值为： 9.000000
    
}